在开始介绍内存泄露所涉及到一系列概念之前，我们有必要对内存泄露是什么做一个了解。

那么什么是内存泄露呢？

> 我的理解是这样的： 当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而就导致对象不能被回收。这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏。

要分析Java中的内存泄露我们必须得如下几个概念有清楚的认识：

> 1. 在Java中内存区域划分
> 2. Java中的GC内存回收机制
> 3. Java中的内存分配策略
> 4. Java引用对象的分类

除此之外，我们还应该思考的问题：

> 1. 内存泄露发生在Java内存区域中的哪个区域
> 2. 内存泄露的后果是什么？
> 3. 内存泄露Memory Leak 和 内存溢出 OutOfMemoryError 有必然的联系吗？或者说是两者之间的区别是啥？


下面首先分析Java中内存的划分：

## Java的内存区域划分

与其说是Java的内存区域划分不如说是JVM的内存区域划分，为什么呢？我们知道Java其实是运行在Java虚拟机上的，因此一般大家讲到的Java内存其实就是JVM内存。

因此下文统一称为：JVM内存！

【图解】

以往经常听到那些老鸟说，Java的内存分为：堆、栈！之前还总是投去膜拜的眼神，当我读到《深入理解Java虚拟机》时，发现这种说法原来Too young , Too Sample!

其实JVM的运行时内存分为如下5个区域：

* 程序计数器： 记录正在执行的虚拟机字节码的地址
* 虚拟机栈： 方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧
* 本地方法栈：虚拟机的Native方法执行的内存区
* Java堆：对象分配内存的区域
* 方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据
	* 常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分


至于五个区域更详细的解释，强烈建议读《深入理解Java虚拟机》这本书!

## Java 中的内存回收机制:GC 机制

简单的说呢就是：某对象不再有任何的引用的时候进行回收，来释放内存。

GC——Garbage Collection，垃圾收集！对于GC来说，必须要明白三件事：

1. 哪些内存需要回收？
2. 何时回收？
3. 如何回收？

在讨论上面3个问题之前我们必须要搞明白一点，GC发生在JVM内存区域中的哪一块？

> JVM的运行时内存区域包括：程序计数器、虚拟机栈、本地方法栈这三个随线程而生，随线程而灭的区域。栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个内存区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束火线程结束时，内存自然就着回收了。Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个接口中的多个实现类需要的内存可能也不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器所关注的就是部分内存。

那么接下来讨论刚才提出的三个问题：

### 问题一：哪些内存需要回收？

Java使用根搜索算法（GC Roots Tracing）判定对象是否存活，这个算法的基本思路是：通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么他们就被判定为是可以被回收的对象

[图解]

根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。至此，引出了Java中关于引用的概念，那么Java中引用分为哪几类呢？在Java 1.2之后，Java对引用进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。

* Strong Reference : 程序中普遍存在的，类似”Object obj = new Object()“这类的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
* Soft Reference ：指一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。
* Weak Reference： 用来描述非必须对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
* Phantom Reference： 为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。

### 问题二：何时回收？

在根搜索算法中探测到不可达对象时，它们暂时处于”缓刑“阶段，要真正宣告一个对象死亡，至少要经过两次标记过程，在第二次标记结束后，如果对象还是没有逃脱，那么就会被回收；如果第逃脱第二次标记，那么就可以存活下来。

### 问题三：如何回收？

垃圾回收器根据相应的垃圾回收算法将未逃脱的对象进行回收。

## Java中的内存分配策略

对象的内存分配，往大方向上讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下有可能直接分配在老年代上，分配的规则依据使用的是哪一种垃圾收集器而定。


上文对内存泄露的概念做了一些大体的介绍！下面我们来回答文章开头提出的几个问题：

### 问题一： 内存泄露发生在Java内存区域中的哪个区域

根据上文中的介绍，我们可以清楚的知道，内存泄露发生在Java中的堆内存。

### 问题二： 内存泄露的后果是什么？

内存泄漏会因为减少可用内存的数量从而降低计算机的性能。最终，在最糟糕的情况下，过多的可用内存被分配掉导致全部或部分设备停止正常工作，或者应用程序崩溃。

在以下情况，内存泄漏导致较严重的后果：

*	程序运行后置之不理，并且随着时间的流失消耗越来越多的内存（比如服务器上的后台任务，尤其是嵌入式系统中的后台任务，这些任务可能被运行后很多年内都置之不理）；
*	新的内存被频繁地分配，比如当显示电脑游戏或动画视频画面时；
*	程序能够请求未被释放的内存（比如共享内存），甚至是在程序终止的时候；
*	泄漏在操作系统内部发生；
*	泄漏在系统关键驱动中发生；
*	内存非常有限，比如在嵌入式系统或便携设备中；
*	当运行于一个终止时内存并不自动释放的操作系统（比如AmigaOS）之上，而且一旦丢失只能通过重启来恢复。

### 问题三： 内存泄露Memory Leak 和 内存溢出 OutOfMemoryError 有必然的联系吗？或者说是两者之间的区别是啥

内存泄露：使用完的对象本该被回收，然而却没有被回收，因此就发生了内存泄露，即Memory Leak;
内存溢出：在堆内存中没有足够的内存来完成实例的分配，并且堆空间无法再扩展的情况下，才会抛出OutOfMemoryError 。

至于两者之间的联系，我感觉两者之间没有必然的联系。如果非要说有联系的话，在这种情况下可以说有联系：本来应用程序的内存剩下了50M，而内存泄露造成了5M空间的浪费，恰好在此时需要申请一块48M的内存空间，发现没有足够的空间来分配，就会抛出OutOfMemoryError。




