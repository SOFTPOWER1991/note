# 硬件绘图基本原理

屏幕显示图像的基本原理：
> 显示器是由一个个物理显示单元组成，没一个单元称为一个物理像素点，每一个像素点可以发出多种颜色，显示器成相的原理就是在不同的物理像素点上显示不同的颜色，最终构成完整的图像。
> 
> 为了更新显示画面，显示器是以固定的频率刷新，比如有一部手机屏幕的刷新频率是60Hz。当一帧图像绘制完毕后准备绘制下一帧时，显示器会发出一个垂直同步信号 VSync，60Hz的屏幕就会在一秒内发出60次这样的信号。而这个信号主要是用于同步CPU、GPU 和 显示器的。

计算机系统中，CPU、GPU、显示器的协作方式：
> CPU将计算好的内容提交给GPU，GPU渲染后放入帧缓冲区，然后视频控制器按照同步信号从帧缓冲区取帧数据传递给显示器显示。
> CPU 和 GPU 的任务：CPU主要用于基本数学和逻辑运算，而GPU主要执行和图形处理相关的复杂的数学（如矩阵变化和几何计算）， GPU的主要作用就是确定最终输送给显示器的各个像素点的色值。

操作系统绘制API的封装

> 最终的图形计算和绘制都是由相应的硬件来完成，而直接操作硬件的指令通常都会有os屏蔽，应用开发者通常不会直接面对硬件，操作系统屏蔽了这些底层硬件操作后会提供一些封装后的API供操作系统之上的应用调用，但是对于应用开发者来说，直接调用操作系统的API比较复杂，所以，几乎所有用于开发GUI程序的编程语言都会在操作系统之上再封装一层，将操作系统原生API封装在一个编程框架和模型中。比如Android SDK，ios的UIKit。 他们都将操作系统API抽象成一个基础对象，然后再定义一套规则来描述UI，比如：UI树结构、UI操作的单线程原则。

Flutter的UI系统

> 无论是Android SDK 还是IOS 的 UIkit，它们只是语言载体和底层的系统不同而已。

> Flutter的原理：
> 使用同一种编程语言开发，然后针对不同操作系统API抽象一个对上接口一致，对下适配不同操作系统的的中间层，然后在打包编译时再使用相应的中间层代码.
> 它提供了一套Dart API，然后在底层通过OpenGL这种跨平台的绘制库（内部会调用操作系统API）实现了一套代码跨多端。由于Dart API也是调用操作系统API，所以它的性能接近原生。
> 虽然Dart是先调用了OpenGL，OpenGL才会调用操作系统API，但是这仍然是原生渲染，因为OpenGL只是操作系统API的一个封装库，它并不像WebView渲染那样需要JavaScript运行环境和CSS渲染器，所以不会有性能损失。

Flutter对应用开发者定义的开发标准：

> 组合和响应式。 我们要开发一个UI界面，通过组合其它Widget来实现，Flutter中，一切都是Widget，当UI要发生变化时，我们不去直接修改DOM，而是通过更新状态，让Flutter UI系统来根据新的状态来重新构建UI。

Element

> 最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout,渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。

Element是Widget在UI树具体位置的一个实例化对象，大多数Element只有唯一的renderObject，但还有一些Element会有多个子节点，如继承自RenderObjectElment的一些类，比如：MultiChildRenderObjectElement，最终所有Element的RenderObject构成一棵树，即渲染树，render tree。

#### Element的生命周期：

#### BuildContext

#### RenderObject


#### RenderBox

#### 从启动到显示 

早上来还在写代码，中午就被约谈 “业务线调整，你要离开了。” 然后，我就这样被裁员了。


#### Flutter 采用Dart语言开发，Dart的特点：JIT， AOT

#### 静态编译 与 动态解耦 

















































