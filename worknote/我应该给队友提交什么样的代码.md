本文记录这波迭代中对代码规范的一些反思。其中包括：
	1.	我应该给队友提交什么样的代码？
	2.	我应该给队友提交什么样的git commit 信息？ 
====================华丽丽的分割线=====================
这个季度移动端有一个代码规范检测的关键任务，其中用到了阿里巴巴的代码扫描插件，链接地址：https://yq.aliyun.com/articles/69327

=====alibaba代码扫描插件====
插件安装，与使用 与介绍



=====

我记录下来，时刻用来警醒自己同时期望本文能对你有所帮助。

=========代码的坏味道-=-=======
不久之前在读一本书《重构-改善既有代码的质量》一书，其中提到了代码的坏味道，一共罗列了22中代码的坏味道，我想在此一一罗列出来，即使占用大量篇幅，也不过分：

1. Duplicated Code 重复代码
2. Long Method 过长函数
3. Large Class 过大的类
4. Long Parameter List 过长的参数
5. Divergent change 发散式变化
6. Shotgun Surgery  霰弹式修改
7. Feature Envy 依恋清洁


	•	Duplicated Code（重复的代码）
	◦	设法将它们合而为一，程序会变得更好。
	•	Long Method（过长函数）
	◦	需要以注释来说明点什么的时候，就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。可以对一组或甚至一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途就可以。关键不在于函数的长度，而在于函数「做什么」和「如何做」之间的语义距离。
	•	Large Class（过大类） 
	•	Long Parameter List（过长参数列） 
	•	Divergent Change（发散式变化）
	◦	一个 class 受多种变化的影响是坏味道
	•	Shotgun Surgery（散弹式修改）
	◦	一个变化引发多个 class 的变化是坏味道
	•	Feature Envy（依恋情结）
	◦	一个类里的某个函数所有使用的数据和逻辑绝大部分来源其他类，需要对这个函数进
	•	Data Clumps（数据泥团）
	◦	总是出现在一起的数据应该有属于他们自己的对象
	•	Primitive Obsession（基本型别偏执）
	◦	使用小对象替换基本类型
	•	Switch Statements（switch惊悚现身）
	◦	减少使用 switch 使用统一的结构进行替代，多态取代条件表达式
	•	Parallel Inheritance Hierarchies（平行继承体系）
	◦	每当你为某个 class 增加一个 subclass，必须也为另一个class相应增加一个subclass 是坏味道
	•	Lazy Class（冗赘类） 
	•	Speculative Generality（夸夸其谈未来性）
	◦	不要为未来考虑太多
	•	Temporary Field（令人迷惑的暂时值域）
	◦	instance 的变量仅为某种特定情势而设，需要为这些和这个临时变量相关的代码放到一个新的地方
	•	Message Chains（过度耦合的消息链） 
	•	Middle Man（中间转手人）
	◦	某个class接口有一半的函数都委托给其他class 是坏味道
	•	Inappropriate Intimacy（狎昵关系）
	◦	两个 class 联系过于紧密，可以将他们拆散，或者提取共有部分放到新的 class
	•	Alternative Classes with Different Interfaces（异曲同工的类） 
	•	Incomplete Library Class（不完美的程序库类）
	◦	复用可能导致过去设计
	•	Data Class（纯数据类）
	◦	只拥有一些值域（fields），以及用于访问（读写〕这些值域的函数是坏味道
	•	Refused Bequest（被拒绝的遗贈）
	◦	Subclasses 应该继承superclasses的函数和数据
	•	Comments（过多的注释）
	◦	当你感觉需要撰写注释，请先尝试重构，试着让所有注释都变得多余

=========代码的坏味道-=-=======


Java代码扫描插件给我的启发：


1. 方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase，必须遵从驼峰形式
2. 枚举字段需要加上注释
3. 不用的代码及时清理
4. 常量名-应该全部用大写，中间下划线
5. 不用的过时的类或者方法，用必要使用新的API
6. case 需要提供default分支
7. 不允许使用魔法值
8. equals 颠倒写

* long 或者 Long初始赋值时，必须使用大写的L，不能用小写的L，小写容易跟数字L 混淆，造成误解；
* 在if/else / for /while /do 语句中必须使用大括号，即使只有一行代码；
* 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度；
* 获取当前毫秒数：System.currentTimeMillis(); 而不是：new Date().getTime();
* 所有的覆写方法，必须加@Override注解；
* 使用正则表达式时，利用好预编译功能，可以有效加快正则匹配速度
* 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。
* 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端：

===========git commit ===========





